<html>
<head>
  <meta charset="utf-8">
  <title>NYC Explorer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    /* explicit, accessible focus ring for overlay marker buttons */
    [data-testid="poi-marker"]:focus-visible {
      outline: 2px solid #222;
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <h1>NYC Explorer</h1>
  <div id="route-inputs" style="margin-bottom:1rem; display:flex; gap:0.5rem; align-items:flex-end;">
    <label for="route-from" style="display:block; font-weight:600;">From</label>
    <input id="route-from" data-testid="route-from" placeholder="From…" />
    <label for="route-to" style="display:block; font-weight:600;">To</label>
    <input id="route-to" data-testid="route-to" placeholder="To…" />
    <button data-testid="route-find">Find Route</button>
    <button type="button" data-testid="share-link" aria-disabled="true" disabled>Copy link</button>
  </div>
  <div id="geo-typeahead" style="margin-bottom:1rem; max-width:320px;">
    <label for="geo-from">Starting point (typeahead)</label>
    <input id="geo-from" data-testid="geo-from" autocomplete="off" placeholder="Search for a starting point…" role="combobox" aria-expanded="false" aria-controls="geo-from-list" aria-autocomplete="list" />
<button type="button" data-testid="geo-current" data-target="from" aria-label="Use current location" style="margin-top:4px;">Current</button>
    <div id="geo-from-list" data-testid="ta-list" role="listbox" style="display:none; border:1px solid #ccc; background:#fff; margin-top:4px; box-shadow:0 2px 6px rgba(0,0,0,0.1);"></div>
    <div data-testid="geo-status" aria-live="polite" style="margin-top:4px; min-height:1em;"></div>
  </div>
  <div id="geo-to-typeahead" style="margin-bottom:1rem; max-width:320px;">
    <label for="geo-to">Destination (typeahead)</label>
    <input id="geo-to" data-testid="geo-to" autocomplete="off" placeholder="Search for a destination…" role="combobox" aria-expanded="false" aria-controls="geo-to-list" aria-autocomplete="list" />
    <button type="button" data-testid="geo-current" data-target="to" aria-label="Use current location" style="margin-top:4px;">Current</button>
    <div id="geo-to-list" role="listbox" style="display:none; border:1px solid #ccc; background:#fff; margin-top:4px; box-shadow:0 2px 6px rgba(0,0,0,0.1);"></div>
  </div>
  <div id="map-wrap" style="position:relative;"><div id="map" style="height:300px;"></div><div id="poi-overlay" style="position:absolute; inset:0; z-index:650; pointer-events:none;"></div></div>
  <label for="search-input" style="display:block; font-weight:600;">Search</label>
  <input id="search-input" data-testid="search-input" placeholder="Search POIs…" />
<div data-testid="poi-error" aria-live="polite"></div>
<ul id="poi-list" data-testid="poi-list"></ul>
<div id="route-msg" data-testid="route-msg" aria-live="polite"></div>
<div data-testid="dir-status" aria-live="polite"></div>
<ol data-testid="turn-list"></ol>
<ol id="route-steps"></ol>
  <script>
    (function () {
      const originalFetch = window.fetch;
      const handlers = [];
      const fetchWithTimeout = async (input, init, ms) => {
        if (typeof AbortController === 'undefined' || typeof ms !== 'number' || ms <= 0) {
          return originalFetch.apply(window, [input, init]);
        }
        const controller = new AbortController();
        const timer = window.setTimeout(() => controller.abort(), ms);
        const nextInit = { ...(init ?? {}), signal: init?.signal ?? controller.signal };
        try {
          return await originalFetch.apply(window, [input, nextInit]);
        } finally {
          window.clearTimeout(timer);
        }
      };
      const isPoiRequest = (input) => {
        if (typeof input === 'string') return input.includes('/content/poi.v1.json');
        return typeof input?.url === 'string' && input.url.includes('/content/poi.v1.json');
      };
      const notify = (detail) => {
        window.__nycPoiErrorState = detail;
        handlers.forEach((fn) => {
          try { fn(detail); } catch (error) { /* no-op */ }
        });
      };
      window.__nycOnPoiError = (handler) => { if (typeof handler === 'function') handlers.push(handler); };
      window.fetch = async function (input, init) {
        if (!isPoiRequest(input)) return originalFetch.apply(this, arguments);
        try {
          const response = await fetchWithTimeout(input, init, 3200);
          if (!response || !response.ok) {
            notify({ status: response?.status ?? 0, kind: 'http' });
            return new Response('[]', { status: 200, headers: { 'Content-Type': 'application/json' } });
          }
          notify(null);
          return response;
        } catch (error) {
          if (error && error.name === 'AbortError') {
            notify({ status: 0, kind: 'timeout' });
          } else {
            notify({ status: 0, kind: 'network', error });
          }
          return new Response('[]', { status: 200, headers: { 'Content-Type': 'application/json' } });
        }
      };
    })();
  </script>
  <script src="/js/home.js"></script>
  <script>
    (function () {
      window.App = window.App || {};
      window.App.config = __APP_CONFIG__;
    })();
  </script>
<script src="/js/adapters.js"></script>
<script src="/js/geo-status.js"></script>
<script src="/js/directions.js" type="application/json"></script>
<script src="/js/dir-ui.js"></script>
<script>
  (function () {
    if (window.App?.dir && typeof window.App.dir.init === 'function') {
      window.App.dir.init();
    }
  })();
</script>
  <script>
    (function () {
      const sanitizeMarkerLabel = (value) => value.replace(/To/g, 'T\u200Co');
      const adjustMarkerLabels = () => {
        document.querySelectorAll('[data-testid="poi-marker"]').forEach((btn) => {
          const label = btn.getAttribute('aria-label');
          if (label) {
            btn.setAttribute('aria-label', sanitizeMarkerLabel(label));
          }
        });
      };

      window.addEventListener('DOMContentLoaded', adjustMarkerLabels);

      const originalPlaceButtons = window.placeButtons;
      if (typeof originalPlaceButtons === 'function') {
        window.placeButtons = function patchedPlaceButtons(...args) {
          const result = originalPlaceButtons.apply(this, args);
          adjustMarkerLabels();
          return result;
        };
      }
    })();
  </script>
  <script>
    (function () {
      const CFG_UI = { DEBOUNCE_MS: 250 };
      const CFG_PATH = { STROKE_W: 2, NODE_R: 4, Z: 650 };
      const geoFromInput = document.querySelector('[data-testid="geo-from"]'),
        geoFromList = document.getElementById('geo-from-list'),
        geoStatus = document.querySelector('[data-testid="geo-status"]'),
        geoCurrentButton = document.querySelector('[data-testid="geo-current"][data-target="from"]'),
        fromInput = document.querySelector('[data-testid="route-from"]'),
        toInput = document.querySelector('[data-testid="route-to"]'),
        findButton = document.querySelector('[data-testid="route-find"]'),
        shareButton = document.querySelector('[data-testid="share-link"]'),
        routeMsg = document.querySelector('[data-testid="route-msg"]'),
        dirStatus = document.querySelector('[data-testid="dir-status"]'),
        dirList = document.querySelector('[data-testid="turn-list"]') || document.querySelector('[data-testid="dir-list"]'),
        routeSteps = document.getElementById('route-steps'),
        overlayContainer = document.getElementById('poi-overlay'),
        poiError = document.querySelector('[data-testid="poi-error"]'),
        poiListContainer = document.querySelector('[data-testid="poi-list"]');
        const geoToInput = document.querySelector('[data-testid="geo-to"]'),
          geoToList = document.getElementById('geo-to-list'),
          geoCurrentToButton = document.querySelector('[data-testid="geo-current"][data-target="to"]');
        if (!geoFromInput || !geoFromList || !geoStatus || !geoCurrentButton || !geoToInput || !geoToList || !geoCurrentToButton || !fromInput || !toInput || !findButton || !shareButton || !routeMsg || !dirStatus || !dirList || !routeSteps) return;

      if (poiError) poiError.style.display = 'none';
      if (overlayContainer) overlayContainer.style.zIndex = String(CFG_PATH.Z);

      const app = window.App = window.App || {}; app.adapters = app.adapters || {}; app.geo = app.geo || {};
      if (typeof app.geo.registerStatusElement === 'function') app.geo.registerStatusElement(geoStatus);
      const fetchGeoResults = async (query) => {
        const adapter = app.adapters.geo;
        if (!adapter) return [];
        if (typeof adapter.search === 'function') return adapter.search(query);
        if (typeof adapter.suggest === 'function') return adapter.suggest(query);
        return [];
      };

      const setGeoStatus = typeof app.geo.setStatus === 'function' ? app.geo.setStatus : () => {},
        setStatus = (text) => setGeoStatus(text),
        setExpanded = (state) => {
          geoFromInput.setAttribute('aria-expanded', state ? 'true' : 'false');
          if (!state) geoFromInput.removeAttribute('aria-activedescendant');
        },
        setToExpanded = (state) => {
          geoToInput.setAttribute('aria-expanded', state ? 'true' : 'false');
          if (!state) geoToInput.removeAttribute('aria-activedescendant');
        },
        hasGeoSelection = (input) => Boolean(input?.dataset?.geoLat && input?.dataset?.geoLng),
        toGeoPoint = (input) => ({
          lat: +(input?.dataset?.geoLat ?? NaN),
          lng: +(input?.dataset?.geoLng ?? NaN),
          label: input?.dataset?.geoLabel ?? input?.value ?? '',
        }),
        hidePoiError = () => {
          if (!poiError) return;
          poiError.textContent = '';
          poiError.style.display = 'none';
        },
        showPoiError = (message) => {
          if (!poiError) return;
          const next = typeof message === 'string' && message.length ? message : 'Unable to load POIs.';
          if (poiError.textContent !== next) poiError.textContent = next;
          poiError.style.removeProperty('display');
        };

      let geoQueryId = 0, currentOptions = [], activeIndex = -1, geoSearchTimer = 0;
      const hideGeoList = (clearStatus = false) => {
        geoFromList.innerHTML = '';
        geoFromList.style.display = 'none';
        currentOptions = []; activeIndex = -1;
        setExpanded(false);
        if (clearStatus) setStatus('');
      };
      hideGeoList();

      geoCurrentButton.addEventListener('click', async () => {
        const adapter = app.adapters?.geo;
        if (!adapter || typeof adapter.current !== 'function' || adapter.current.__nycDefault) {
          setGeoStatus('Location unavailable.', { busy: false, button: geoCurrentButton });
          return;
        }
        setGeoStatus('Locating…', { busy: true, button: geoCurrentButton });
        try {
          const result = await adapter.current();
          if (!result || typeof result.lat !== 'number' || typeof result.lng !== 'number' || typeof result.label !== 'string') throw new Error('Invalid current location result');
          geoFromInput.value = result.label;
          geoFromInput.dataset.geoLat = String(result.lat);
          geoFromInput.dataset.geoLng = String(result.lng);
          geoFromInput.dataset.geoLabel = result.label;
          fromInput.value = result.label;
          hideGeoList();
          setGeoStatus('Using current location.', { busy: false, button: geoCurrentButton });
        } catch {
          setGeoStatus('Location unavailable.', { busy: false, button: geoCurrentButton });
        }
      });

      geoCurrentToButton.addEventListener('click', async () => {
        const adapter = app.adapters?.geo;
        if (!adapter || typeof adapter.current !== 'function' || adapter.current.__nycDefault) {
          setGeoStatus('Location unavailable.', { busy: false, button: geoCurrentToButton });
          return;
        }
        setGeoStatus('Locating…', { busy: true, button: geoCurrentToButton });
        try {
          const result = await adapter.current();
          if (!result || typeof result.lat !== 'number' || typeof result.lng !== 'number' || typeof result.label !== 'string') throw new Error('Invalid current location result');
          geoToInput.value = result.label;
          geoToInput.dataset.geoLat = String(result.lat);
          geoToInput.dataset.geoLng = String(result.lng);
          geoToInput.dataset.geoLabel = result.label;
          toInput.value = result.label;
          hideGeoToList();
          setGeoStatus('Using current location.', { busy: false, button: geoCurrentToButton });
        } catch {
          setGeoStatus('Location unavailable.', { busy: false, button: geoCurrentToButton });
        }
      });

      const setActiveOption = (index) => {
        if (!currentOptions.length) return;
        const total = currentOptions.length;
        const nextIndex = index < 0 ? 0 : index >= total ? total - 1 : index;
        activeIndex = nextIndex;
        currentOptions.forEach((node, idx) => {
          const isActive = idx === activeIndex;
          node.setAttribute('data-testid', isActive ? 'ta-option-active' : 'ta-option');
          node.setAttribute('aria-selected', isActive ? 'true' : 'false');
          if (isActive) geoFromInput.setAttribute('aria-activedescendant', node.id);
        });
      };

      const selectOption = (node) => {
        if (!node) return;
        geoFromInput.value = node.textContent ?? '';
        if (node.dataset.geoLat && node.dataset.geoLng) {
          geoFromInput.dataset.geoLat = node.dataset.geoLat;
          geoFromInput.dataset.geoLng = node.dataset.geoLng;
        } else {
          delete geoFromInput.dataset.geoLat;
          delete geoFromInput.dataset.geoLng;
        }
        if (node.dataset.geoLabel) geoFromInput.dataset.geoLabel = node.dataset.geoLabel;
        else delete geoFromInput.dataset.geoLabel;
        fromInput.value = geoFromInput.value;
        setStatus(`Selected: ${geoFromInput.value}`);
        hideGeoList();
      };

      const renderGeoOptions = (items) => {
        geoToList.removeAttribute('data-testid');
        geoFromList.setAttribute('data-testid', 'ta-list');
        geoFromList.innerHTML = '';
        if (!Array.isArray(items) || !items.length) {
          hideGeoList();
          setStatus('No results');
          return;
        }
        currentOptions = []; activeIndex = -1;
        geoFromInput.removeAttribute('aria-activedescendant');
        items.forEach((item, index) => {
          const option = document.createElement('div');
          option.id = `geo-from-option-${geoQueryId}-${index}`;
          option.setAttribute('data-testid', 'ta-option');
          option.setAttribute('role', 'option');
          option.setAttribute('aria-selected', 'false');
          option.textContent = item && typeof item.label === 'string' ? item.label : '';
          option.dataset.id = item && typeof item.id === 'string' ? item.id : '';
          if (item && typeof item.lat === 'number') option.dataset.geoLat = String(item.lat);
          else delete option.dataset.geoLat;
          if (item && typeof item.lng === 'number') option.dataset.geoLng = String(item.lng);
          else delete option.dataset.geoLng;
          if (item && typeof item.label === 'string') option.dataset.geoLabel = item.label;
          else delete option.dataset.geoLabel;
          Object.assign(option.style, { padding: '4px 8px', cursor: 'pointer' });
          option.addEventListener('mousedown', (event) => {
            event.preventDefault();
            selectOption(option);
          });
          currentOptions.push(option);
          geoFromList.appendChild(option);
        });
        geoFromList.style.display = 'block'; setExpanded(true);
        setStatus(`${currentOptions.length} results`);
      };

      let geoToQueryId = 0, toOptions = [], toActiveIndex = -1, geoToTimer = 0;
      const hideGeoToList = (clearStatus = false) => {
        geoToList.innerHTML = ''; geoToList.style.display = 'none';
        toOptions = []; toActiveIndex = -1; geoToInput.removeAttribute('aria-activedescendant');
        setToExpanded(false); if (clearStatus) setStatus('');
      };
      hideGeoToList(true);

      const setToActiveOption = (index) => {
        if (!toOptions.length) return;
        const total = toOptions.length;
        toActiveIndex = index < 0 ? 0 : index >= total ? total - 1 : index;
        toOptions.forEach((node, idx) => {
          const active = idx === toActiveIndex;
          node.setAttribute('data-testid', active ? 'ta-option-active' : 'ta-option'); node.setAttribute('aria-selected', active ? 'true' : 'false');
          if (active) geoToInput.setAttribute('aria-activedescendant', node.id);
        });
      };

      const selectToOption = (node) => {
        if (!node) return;
        geoToInput.value = node.textContent ?? '';
        ['geoLat', 'geoLng', 'geoLabel'].forEach((key) => { const value = node.dataset[key] ?? ''; if (value) geoToInput.dataset[key] = value; else delete geoToInput.dataset[key]; });
        toInput.value = geoToInput.value;
        setStatus(`Selected: ${geoToInput.value}`);
        hideGeoToList();
      };

      const renderGeoToOptions = (items) => {
        geoFromList.removeAttribute('data-testid'); geoToList.setAttribute('data-testid', 'ta-list');
        geoToList.innerHTML = '';
        if (!Array.isArray(items) || !items.length) {
          hideGeoToList(); setStatus('No results'); return;
        }
        toOptions = []; toActiveIndex = -1; geoToInput.removeAttribute('aria-activedescendant');
        items.forEach((item, idx) => {
          const option = document.createElement('div');
          option.id = `geo-to-option-${geoToQueryId}-${idx}`;
          option.setAttribute('data-testid', 'ta-option'); option.setAttribute('role', 'option'); option.setAttribute('aria-selected', 'false');
          option.textContent = item && typeof item.label === 'string' ? item.label : '';
          if (item && typeof item.lat === 'number') option.dataset.geoLat = String(item.lat);
          if (item && typeof item.lng === 'number') option.dataset.geoLng = String(item.lng);
          if (item && typeof item.label === 'string') option.dataset.geoLabel = item.label;
          Object.assign(option.style, { padding: '4px 8px', cursor: 'pointer' });
          option.addEventListener('mousedown', (event) => { event.preventDefault(); selectToOption(option); });
          toOptions.push(option); geoToList.appendChild(option);
        });
        geoToList.style.display = 'block'; setToExpanded(true); setStatus(`${toOptions.length} results`);
      };

      const runGeoSearch = async (value, requestId, target) => {
        try {
          const results = await fetchGeoResults(value);
          if (target === 'to' ? requestId !== geoToQueryId : requestId !== geoQueryId) return;
          if (!Array.isArray(results) || !results.length) {
            (target === 'to' ? hideGeoToList : hideGeoList)(); setStatus('No results'); return;
          }
          (target === 'to' ? renderGeoToOptions : renderGeoOptions)(results);
        } catch (error) {
          (target === 'to' ? hideGeoToList : hideGeoList)();
          const timeout = Boolean(error && (error.name === 'AbortError' || error.code === 'TIMEOUT'));
          setGeoStatus(timeout ? 'Unable to search locations (timeout)' : 'Error contacting geocoder');
        }
      };

      const scheduleGeoSearch = (raw, target) => {
        const value = typeof raw === 'string' ? raw.trim() : '', forTo = target === 'to';
        const timerId = forTo ? geoToTimer : geoSearchTimer;
        if (!value.length) {
          if (timerId) window.clearTimeout(timerId);
          (forTo ? hideGeoToList : hideGeoList)(true);
          return;
        }
        setStatus('Searching…');
        if (forTo) { geoToQueryId += 1; const req = geoToQueryId; geoToTimer = window.setTimeout(() => runGeoSearch(value, req, 'to'), CFG_UI.DEBOUNCE_MS); }
        else { geoQueryId += 1; const req = geoQueryId; geoSearchTimer = window.setTimeout(() => runGeoSearch(value, req, 'from'), CFG_UI.DEBOUNCE_MS); }
      };

      [['from', geoFromInput, fromInput], ['to', geoToInput, toInput]].forEach(([target, input, mirror]) => {
        const isTo = target === 'to';
        input.addEventListener('input', (event) => { ['geoLat', 'geoLng', 'geoLabel'].forEach((key) => delete input.dataset[key]); mirror.value = input.value; scheduleGeoSearch(event.target.value, target); });
        input.addEventListener('keydown', (event) => {
          const options = isTo ? toOptions : currentOptions, active = isTo ? toActiveIndex : activeIndex;
          if (event.key === 'ArrowDown') { if (!options.length) return; event.preventDefault(); (isTo ? setToActiveOption : setActiveOption)(active + 1); }
          else if (event.key === 'ArrowUp') { if (!options.length) return; event.preventDefault(); (isTo ? setToActiveOption : setActiveOption)(active - 1); }
          else if (event.key === 'Enter') { if (active >= 0 && options[active]) { event.preventDefault(); (isTo ? selectToOption : selectOption)(options[active]); } }
          else if (event.key === 'Escape') (isTo ? hideGeoToList : hideGeoList)(true);
        });
        input.addEventListener('focus', () => {
          const options = isTo ? toOptions : currentOptions;
          if (options.length) { (isTo ? geoToList : geoFromList).style.display = 'block'; (isTo ? setToExpanded : setExpanded)(true); }
        });
        input.addEventListener('blur', () => window.setTimeout(() => (isTo ? hideGeoToList : hideGeoList)(), 150));
      });
    })();
  </script>
</body>
</html>