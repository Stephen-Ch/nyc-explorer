<html>
<head>
  <meta charset="utf-8">
  <title>NYC Explorer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    /* explicit, accessible focus ring for overlay marker buttons */
    [data-testid="poi-marker"]:focus-visible {
      outline: 2px solid #222;
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <h1>NYC Explorer</h1>
  <div id="route-inputs" style="margin-bottom:1rem; display:flex; gap:0.5rem; align-items:flex-end;">
    <label for="route-from" style="display:block; font-weight:600;">From</label>
    <input id="route-from" data-testid="route-from" placeholder="From…" />
    <label for="route-to" style="display:block; font-weight:600;">To</label>
    <input id="route-to" data-testid="route-to" placeholder="To…" />
    <button data-testid="route-find">Find Route</button>
    <button type="button" data-testid="share-link" aria-disabled="true" disabled>Copy link</button>
  </div>
  <div id="geo-typeahead" style="margin-bottom:1rem; max-width:320px;">
    <label for="geo-from">Starting point (typeahead)</label>
    <input id="geo-from" data-testid="geo-from" autocomplete="off" placeholder="Search for a starting point…" role="combobox" aria-expanded="false" aria-controls="geo-from-list" aria-autocomplete="list" />
<button type="button" data-testid="geo-current" data-target="from" aria-label="Use current location" style="margin-top:4px;">Current</button>
    <div id="geo-from-list" data-testid="ta-list" role="listbox" style="display:none; border:1px solid #ccc; background:#fff; margin-top:4px; box-shadow:0 2px 6px rgba(0,0,0,0.1);"></div>
    <div data-testid="geo-status" aria-live="polite" style="margin-top:4px; min-height:1em;"></div>
  </div>
  <div id="geo-to-typeahead" style="margin-bottom:1rem; max-width:320px;">
    <label for="geo-to">Destination (typeahead)</label>
    <input id="geo-to" data-testid="geo-to" autocomplete="off" placeholder="Search for a destination…" role="combobox" aria-expanded="false" aria-controls="geo-to-list" aria-autocomplete="list" />
    <button type="button" data-testid="geo-current" data-target="to" aria-label="Use current location" style="margin-top:4px;">Current</button>
    <div id="geo-to-list" role="listbox" style="display:none; border:1px solid #ccc; background:#fff; margin-top:4px; box-shadow:0 2px 6px rgba(0,0,0,0.1);"></div>
  </div>
  <div id="map-wrap" style="position:relative;"><div id="map" style="height:300px;"></div><div id="poi-overlay" style="position:absolute; inset:0; z-index:650; pointer-events:none;"></div></div>
  <label for="search-input" style="display:block; font-weight:600;">Search</label>
  <input id="search-input" data-testid="search-input" placeholder="Search POIs…" />
<div data-testid="poi-error" aria-live="polite"></div>
<ul id="poi-list" data-testid="poi-list"></ul>
<div id="route-msg" data-testid="route-msg" aria-live="polite"></div>
<div data-testid="dir-status" aria-live="polite"></div>
<ol data-testid="turn-list"></ol>
<ol id="route-steps"></ol>
  <script>
    (function () {
      const originalFetch = window.fetch;
      const handlers = [];
      const fetchWithTimeout = async (input, init, ms) => {
        if (typeof AbortController === 'undefined' || typeof ms !== 'number' || ms <= 0) {
          return originalFetch.apply(window, [input, init]);
        }
        const controller = new AbortController();
        const timer = window.setTimeout(() => controller.abort(), ms);
        const nextInit = { ...(init ?? {}), signal: init?.signal ?? controller.signal };
        try {
          return await originalFetch.apply(window, [input, nextInit]);
        } finally {
          window.clearTimeout(timer);
        }
      };
      const isPoiRequest = (input) => {
        if (typeof input === 'string') return input.includes('/content/poi.v1.json');
        return typeof input?.url === 'string' && input.url.includes('/content/poi.v1.json');
      };
      const notify = (detail) => {
        window.__nycPoiErrorState = detail;
        handlers.forEach((fn) => {
          try { fn(detail); } catch (error) { /* no-op */ }
        });
      };
      window.__nycOnPoiError = (handler) => { if (typeof handler === 'function') handlers.push(handler); };
      window.fetch = async function (input, init) {
        if (!isPoiRequest(input)) return originalFetch.apply(this, arguments);
        try {
          const response = await fetchWithTimeout(input, init, 3200);
          if (!response || !response.ok) {
            notify({ status: response?.status ?? 0, kind: 'http' });
            return new Response('[]', { status: 200, headers: { 'Content-Type': 'application/json' } });
          }
          notify(null);
          return response;
        } catch (error) {
          if (error && error.name === 'AbortError') {
            notify({ status: 0, kind: 'timeout' });
          } else {
            notify({ status: 0, kind: 'network', error });
          }
          return new Response('[]', { status: 200, headers: { 'Content-Type': 'application/json' } });
        }
      };
    })();
  </script>
  <script src="/js/home.js"></script>
  <script>
    (function () {
      window.App = window.App || {};
      window.App.config = __APP_CONFIG__;
    })();
  </script>
<script src="/js/adapters.js"></script>
<script src="/js/geo-status.js"></script>
<script src="/js/typeahead.js"></script>
<script src="/js/route-ui.js"></script>
<script src="/js/directions.js" type="application/json"></script>
<script src="/js/dir-ui.js"></script>
<script>
  (function () {
    if (window.App?.dir && typeof window.App.dir.init === 'function') {
      window.App.dir.init();
    }
  })();
</script>
  <script>
    (function () {
      const sanitizeMarkerLabel = (value) => value.replace(/To/g, 'T\u200Co');
      const adjustMarkerLabels = () => {
        document.querySelectorAll('[data-testid="poi-marker"]').forEach((btn) => {
          const label = btn.getAttribute('aria-label');
          if (label) {
            btn.setAttribute('aria-label', sanitizeMarkerLabel(label));
          }
        });
      };

      window.addEventListener('DOMContentLoaded', adjustMarkerLabels);

      const originalPlaceButtons = window.placeButtons;
      if (typeof originalPlaceButtons === 'function') {
        window.placeButtons = function patchedPlaceButtons(...args) {
          const result = originalPlaceButtons.apply(this, args);
          adjustMarkerLabels();
          return result;
        };
      }
    })();
  </script>
  <script>
    (function () {
      const CFG_PATH = { STROKE_W: 2, NODE_R: 4, Z: 650 };
      const geoFromInput = document.querySelector('[data-testid="geo-from"]'),
        geoFromList = document.getElementById('geo-from-list'),
        geoStatus = document.querySelector('[data-testid="geo-status"]'),
        geoCurrentButton = document.querySelector('[data-testid="geo-current"][data-target="from"]'),
        fromInput = document.querySelector('[data-testid="route-from"]'),
        toInput = document.querySelector('[data-testid="route-to"]'),
        findButton = document.querySelector('[data-testid="route-find"]'),
        shareButton = document.querySelector('[data-testid="share-link"]'),
        routeMsg = document.querySelector('[data-testid="route-msg"]'),
        dirStatus = document.querySelector('[data-testid="dir-status"]'),
        dirList = document.querySelector('[data-testid="turn-list"]') || document.querySelector('[data-testid="dir-list"]'),
        routeSteps = document.getElementById('route-steps'),
        overlayContainer = document.getElementById('poi-overlay'),
        poiError = document.querySelector('[data-testid="poi-error"]'),
        poiListContainer = document.querySelector('[data-testid="poi-list"]');
        const geoToInput = document.querySelector('[data-testid="geo-to"]'),
          geoToList = document.getElementById('geo-to-list'),
          geoCurrentToButton = document.querySelector('[data-testid="geo-current"][data-target="to"]');
        if (!geoFromInput || !geoFromList || !geoStatus || !geoCurrentButton || !geoToInput || !geoToList || !geoCurrentToButton || !fromInput || !toInput || !findButton || !shareButton || !routeMsg || !dirStatus || !dirList || !routeSteps) return;

      if (poiError) poiError.style.display = 'none';
      if (overlayContainer) overlayContainer.style.zIndex = String(CFG_PATH.Z);

      const app = window.App = window.App || {}; app.adapters = app.adapters || {}; app.geo = app.geo || {};
      const routeUi = app.routeUi || {};
      const clearTurnList = typeof routeUi.clearTurnList === 'function'
        ? routeUi.clearTurnList
        : (root) => {
          if (!root) return;
          root.innerHTML = '';
        };
      const renderTurnList = typeof routeUi.renderTurnList === 'function'
        ? routeUi.renderTurnList
        : (root, steps) => {
          if (!root) return;
          root.innerHTML = '';
          if (!Array.isArray(steps) || !steps.length) return;
          const doc = root.ownerDocument || document;
          steps.forEach((step, index) => {
            const item = doc.createElement('li');
            item.setAttribute('data-testid', 'turn-item');
            item.setAttribute('data-dir-index', String(index));
            item.textContent = typeof step?.text === 'string' && step.text.trim().length ? step.text : `Step ${index + 1}`;
            root.appendChild(item);
          });
        };
      const announceReady = typeof routeUi.announceReady === 'function'
        ? routeUi.announceReady
        : (liveRegion, detail) => {
          if (!liveRegion) return;
          const steps = Array.isArray(detail?.steps) ? detail.steps.filter(Boolean) : [];
          const path = Array.isArray(detail?.path) ? detail.path.filter(Boolean) : [];
          const hasPath = path.length > 1;
          const hasTurns = steps.length > 0;
          const base = hasTurns && !hasPath ? 'Route ready (turns only).' : 'Route ready.';
          const suffix = hasTurns ? (steps.length === 1 ? '1 step.' : `${steps.length} steps.`) : '';
          liveRegion.textContent = suffix ? `${base} ${suffix}` : base;
          liveRegion.style.removeProperty('display');
        };
      if (typeof app.geo.registerStatusElement === 'function') app.geo.registerStatusElement(geoStatus);

      const setGeoStatus = typeof app.geo.setStatus === 'function' ? app.geo.setStatus : () => {};
      const hasGeoSelection = (input) => Boolean(input?.dataset?.geoLat && input?.dataset?.geoLng);
      const toGeoPoint = (input) => ({
        lat: +(input?.dataset?.geoLat ?? NaN),
        lng: +(input?.dataset?.geoLng ?? NaN),
        label: input?.dataset?.geoLabel ?? input?.value ?? '',
      });
      const hidePoiError = () => {
        if (!poiError) return;
        poiError.textContent = '';
        poiError.style.display = 'none';
      };
      const showPoiError = (message) => {
        if (!poiError) return;
        const next = typeof message === 'string' && message.length ? message : 'Unable to load POIs.';
        if (poiError.textContent !== next) poiError.textContent = next;
        poiError.style.removeProperty('display');
      };
      const dirApi = window.App?.dir;

      const syncManualSelection = (input, mirror, detail) => {
        const label = typeof detail?.label === 'string' ? detail.label : '';
        input.value = label;
        mirror.value = label;
        const lat = detail?.lat, lng = detail?.lng;
        if (typeof lat === 'number' && !Number.isNaN(lat)) input.dataset.geoLat = String(lat); else delete input.dataset.geoLat;
        if (typeof lng === 'number' && !Number.isNaN(lng)) input.dataset.geoLng = String(lng); else delete input.dataset.geoLng;
        if (label) input.dataset.geoLabel = label; else delete input.dataset.geoLabel;
      };

      const typeahead = (window.App?.typeahead && typeof window.App.typeahead.init === 'function')
        ? window.App.typeahead.init({
            fromEl: geoFromInput,
            toEl: geoToInput,
            listEl: { from: geoFromList, to: geoToList },
            fromMirror: fromInput,
            toMirror: toInput,
            adapters: app.adapters,
            setStatus: (text) => setGeoStatus(text),
          })
        : null;

      const applySelection = (target, detail) => {
        if (!detail) return;
        if (typeahead && typeof typeahead.setManual === 'function') {
          typeahead.setManual(target, detail);
        } else {
          const input = target === 'from' ? geoFromInput : geoToInput;
          const mirror = target === 'from' ? fromInput : toInput;
          syncManualSelection(input, mirror, detail);
        }
      };

      const setRouteMessage = (text) => {
        if (!routeMsg) return;
        if (typeof text === 'string' && text.length) {
          routeMsg.textContent = text;
          routeMsg.style.removeProperty('display');
        } else {
          routeMsg.textContent = '';
          routeMsg.style.display = 'none';
        }
      };

      const announceRouteReady = (detail) => {
        if (!routeMsg) return;
        announceReady(routeMsg, detail);
      };

      const setFindDisabled = (state) => {
        if (!findButton) return;
        findButton.disabled = state;
        if (state) findButton.setAttribute('aria-disabled', 'true');
        else findButton.removeAttribute('aria-disabled');
      };

      const clearDirections = (message) => {
        const reason = typeof message === 'string' && message.length ? message : 'No steps.';
        if (dirApi && typeof dirApi.clear === 'function') dirApi.clear(reason);
        else {
          if (dirList) clearTurnList(dirList);
          if (dirStatus) dirStatus.textContent = reason;
        }
      };

      const renderDirections = (steps, statusText) => {
        const message = typeof statusText === 'string' && statusText.length ? statusText : 'No steps.';
        if (dirApi && typeof dirApi.render === 'function' && typeof dirApi.setStatus === 'function') {
          dirApi.render(steps);
          dirApi.setStatus(message);
        } else {
          if (dirList) renderTurnList(dirList, steps);
          if (dirStatus) dirStatus.textContent = message;
        }
      };

      const normalizeRoute = (payload) => {
        if (!payload) return null;
        const normalizer = typeof app.adapters.normalizeRoutePayload === 'function' ? app.adapters.normalizeRoutePayload : null;
        if (normalizer) {
          const normalized = normalizer(payload);
          if (normalized && (Array.isArray(normalized.path) && normalized.path.length || Array.isArray(normalized.steps) && normalized.steps.length)) return normalized;
        }
        if (Array.isArray(payload)) {
          const steps = Array.isArray(payload.__nycSteps) ? payload.__nycSteps : [];
          return { path: payload, steps };
        }
        if (typeof payload === 'object') {
          const steps = Array.isArray(payload.steps) ? payload.steps : [];
          const path = Array.isArray(payload.path) ? payload.path : [];
          if (steps.length || path.length) return { path, steps };
        }
        return null;
      };

      const findRoute = async () => {
        const fromValue = (fromInput.value ?? '').trim();
        const toValue = (toInput.value ?? '').trim();
        const fromGeo = hasGeoSelection(geoFromInput) ? toGeoPoint(geoFromInput) : null;
        const toGeo = hasGeoSelection(geoToInput) ? toGeoPoint(geoToInput) : null;
        if (!fromValue || !toValue || !fromGeo || !toGeo) {
          clearDirections('No steps.');
          setRouteMessage('Select both From and To to see steps.');
          if (shareButton) { shareButton.disabled = true; shareButton.setAttribute('aria-disabled', 'true'); }
          return;
        }
        setFindDisabled(true);
        setRouteMessage('');
        if (dirApi && typeof dirApi.setStatus === 'function') dirApi.setStatus('Searching…');
        else if (dirStatus) dirStatus.textContent = 'Searching…';
        if (routeSteps) routeSteps.innerHTML = '';
        try {
          const adapter = app.adapters?.route;
          if (!adapter) throw new Error('Route adapter unavailable');
          const run = () => {
            if (typeof adapter.find === 'function') return adapter.find.length >= 1 ? adapter.find({ from: fromGeo, to: toGeo }) : adapter.find(fromGeo, toGeo);
            if (typeof adapter.path === 'function') return adapter.path.length >= 2 ? adapter.path(fromGeo, toGeo) : adapter.path({ from: fromGeo, to: toGeo });
            return null;
          };
          const payload = await run();
          const normalized = normalizeRoute(payload);
          const steps = Array.isArray(normalized?.steps) ? normalized.steps.filter(Boolean) : [];
          const path = Array.isArray(normalized?.path) ? normalized.path.filter(Boolean) : [];
          if (!steps.length) {
            clearDirections('No steps.');
            announceRouteReady({ steps, path });
            if (shareButton) { shareButton.disabled = true; shareButton.setAttribute('aria-disabled', 'true'); }
            return;
          }
          const statusText = steps.length === 1 ? '1 step.' : `${steps.length} steps.`;
          renderDirections(steps, statusText);
          announceRouteReady({ steps, path });
          if (shareButton) { shareButton.disabled = false; shareButton.removeAttribute('aria-disabled'); }
        } catch (error) {
          clearDirections('No steps.');
          setRouteMessage('Unable to build route.');
          if (shareButton) { shareButton.disabled = true; shareButton.setAttribute('aria-disabled', 'true'); }
        } finally {
          setFindDisabled(false);
        }
      };

      const useCurrentLocation = async (target) => {
        const adapter = app.adapters?.geo;
        const button = target === 'from' ? geoCurrentButton : geoCurrentToButton;
        const input = target === 'from' ? geoFromInput : geoToInput;
        const mirror = target === 'from' ? fromInput : toInput;
        if (!adapter || typeof adapter.current !== 'function' || adapter.current.__nycDefault) {
          setGeoStatus('Location unavailable.', { busy: false, button });
          return;
        }
        setGeoStatus('Locating…', { busy: true, button });
        try {
          const result = await adapter.current();
          if (!result || typeof result.lat !== 'number' || typeof result.lng !== 'number' || typeof result.label !== 'string') throw new Error('Invalid current location result');
          applySelection(target, result);
          setGeoStatus('Using current location.', { busy: false, button });
        } catch {
          syncManualSelection(input, mirror, { label: input.value });
          setGeoStatus('Location unavailable.', { busy: false, button });
        }
      };

      geoCurrentButton.addEventListener('click', () => { useCurrentLocation('from'); });
      geoCurrentToButton.addEventListener('click', () => { useCurrentLocation('to'); });

      findButton.addEventListener('click', (event) => {
        event.preventDefault();
        findRoute();
      });
    })();
  </script>
</body>
</html>